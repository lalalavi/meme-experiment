{{ block title }}
    Your post received...
{{ endblock }}

{{ block content }}

<style>
	.heart {
	   z-index : 999;
	   position : absolute;
	}
	.heart:before,
	.heart:after {
	   content : "";
	   background-color : #fc2a62;
	   position : absolute;
	   height : 30px;
	   width : 45px;
	   border-radius : 15px 0px 0px 15px;
	}
	.heart:before {
	   transform : rotate(45deg);
	}
	.heart:after {
	   left : 10.5px;
	   transform : rotate(135deg);
	}  	
</style>
	
<script>
	var brd = document.createElement("DIV");
	document.body.insertBefore(brd, document.getElementById("board"));
	// const duration = 3000;
	// const speed = 0.5;
	// const cursorXOffset = 0;
	// const cursorYOffset = -5;
	var hearts = [];
	function generateHeart(x, y, scale)
	{
	   var heart = document.createElement("DIV");
	   heart.setAttribute('class', 'heart');
	   brd.appendChild(heart);
	// heart.time = duration;
	   heart.x = x;
	   heart.y = y;
	// heart.bound = xBound;
	// heart.direction = xStart;
	   heart.style.left = heart.x + "px";
	   heart.style.top = heart.y + "px";
	   heart.scale = scale;
	   heart.style.transform = "scale(" + scale + "," + scale + ")";
	   if(hearts == null)
		hearts = [];
	   hearts.push(heart);
	   return heart;
	}
	</script>
	<script> 
	// //show otree timer lasy 10 sec
	// $(function () {
	// 	$('.otree-timer__time-left').on('update.countdown', function (event) {
	// 		if (event.offset.totalSeconds === 10) {
	// 			$('.otree-timer').show();
	// 		}
	// 	});
	// });
	// 
	</script>

	<p>your post received <label id="iLikes" value="{{l}}">{{l}}</text> likes </p>
	<p id="dislike-text">and	<label id="iDislikes" value="{{d}}"> {{d}}</label> dislikes</p>
	
	

	 <script>
		generateHeart(500, 195, 1);
		generateHeart(550, 195, 1);
		generateHeart(600, 195, 1);
		generateHeart(650, 195, 1);
		generateHeart(690, 190, 1);
		generateHeart(750, 190, 1);
	</script>

	<!-- and 	<text id="iDislikes" value="{{d}}">{{d}}</text> dislikes -->


	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"> </script> 
	<script> 
	var R = Raphael(40, 50, 1200, 1000); // Creates canvas 320 × 200 at 40, 50
	var dot = R.circle(250, 150, 30).attr({ 
	fill: "#FFF", 
	stroke: "#000", 
	"stroke-width": 1 
	}); 
	</script> -->

	<!-- <body>
		<div class = "heart"></div>
	</body>

	to test if it creates the heart --> 



<script>

// if you do not put this stuff it will not get saved

let l        	= document.createElement("input");
	l.type       = 'hidden';
	l.name       = 'iLikes';
	l.id         = 'iLikes';
	l.value      = "{{l}}";

let d        = document.createElement("input");
	d.type       = 'hidden';
	d.name       = 'iDislikes';
	d.id         = 'iDislikes';
	d.value      = "{{d}}";

let dRT          = document.createElement("input");
	dRT.type         = 'hidden';
	dRT.name         = 'dRTFeedback';
	dRT.id           = 'dRTFeedback';
	dRT.value        = '';
	var TStart       = new Date().getTime();
	var TEnd         = new Date().getTime();

	document.addEventListener("DOMContentLoaded", function(debug=true) {
            console.log('Loading info');
            let OtreeBody     = document.getElementsByClassName("_otree-content")[0];
            OtreeBody.appendChild(dRT);
			OtreeBody.appendChild(l); // append likes
			OtreeBody.appendChild(d); // apend dislikes

			let DislikeText = document.getElementById("dislike-text")
			if (js_vars.treatment == "Control") {
				DislikeText.style.visibility = "none"
			}; //hidden

			// l.value = "{{l}}"
			// d.value = "{{d}}"
			// could have done this too

            function addtoev() {
            var bns = document.getElementsByTagName("button");
            for (i = 0; i < bns.length; i++) {
                bns[i].addEventListener("click", function() {
                TEnd      = new Date().getTime();
                dRT.value = +TEnd -TStart;   // end the timer and rewrite the RT value
              });
            }} // what this function is doing is the same as we do when we check
            // if somebody pressed a key, but instead of checking keys, 
            // we check whether they press any buttons :D
            

            window.addEventListener("load",function() {
            addtoev();
            });
        });
</script>

<div class="button">
	 <button class="btn btn-primary">Continue </button> 
</div>

<style>
form .buttons button {
	padding: 5px 10px;
	background-color: #67ab49;
	border: 0;
	border-radius: 3px;
	}

form .buttons .btn-primary {background-color: #67ab49;} 
form .buttons .btn-primary:hover {background-color: #14892c;}  
</style>

{{ endblock }}

<script>

    // DOWNLOAD RAPHAEL. 
    // raphael.js
/*

You can copy and paste the below into your codebase somewhere.
As long as Raphael is a global object, it'll just work.

USAGE (same default values for optional parameters as Rapha�l's "animate" method)
=====
element.animateAlong({
	path: REQUIRED - Path data string or path element,
	rotate: OPTIONAL - Boolean whether to rotate element with the direction it is moving
	                   (this is a beta feature - currently kills existing transformations
	                    and rotation may not be perfect),
	duration: OPTIONAL - Number in milliseconds,
	easing: OPTIONAL - String (see Rapha�l's docs),
	debug: OPTIONAL - Boolean, when set to true, paints the animating path, which is
					  helpful if it isn't already rendered to the screen
},
props - Object literal containing other properties to animate,
callback - Function where the "this" object refers to the element itself
);

EXAMPLE
=======
var rect = paper.rect(0,0,50,50);
rect.animateAlong({
	path: "M0,0L100,100",
	rotate: true,
	duration: 5000,
	easing: 'ease-out',
	debug: true
},
{
	transform: 's0.25',
	opacity: 0
},
function() {
	alert("Our opacity is now:" + this.attr('opacity'));
});

LOADING THIS WEIRD RAPHAEL THING
// */ 

// Raphael.el.animateAlong = function(params, props, callback) {
// 	var element = this,
// 		paper = element.paper,
// 		path = params.path,
// 		rotate = params.rotate,
// 		duration = params.duration,
// 		easing = params.easing,
// 		debug = params.debug,
// 		isElem = typeof path !== 'string';
	
// 	element.path = 
// 		isElem
// 			? path
// 			: paper.path(path);
// 	element.pathLen = element.path.getTotalLength();
// 	element.rotateWith = rotate;
	
// 	element.path.attr({
// 		stroke: debug ? 'red' : isElem ? path.attr('stroke') : 'rgba(0,0,0,0)',
// 		'stroke-width': debug ? 2 : isElem ? path.attr('stroke-width') : 0
// 	});

// 	paper.customAttributes.along = function(v) {
// 		var point = this.path.getPointAtLength(v * this.pathLen),
// 			attrs = {
// 				x: point.x,
// 				y: point.y 
// 			};
// 		this.rotateWith && (attrs.transform = 'r'+point.alpha);
// 		// TODO: rotate along a path while also not messing
// 		//       up existing transformations
		
// 		return attrs;
// 	};

// 	if(props instanceof Function) {
// 		callback = props;
// 		props = null;
// 	}
// 	if(!props) {
// 		props = {
// 			along: 1
// 		};
// 	} else {
// 		props.along = 1;	
// 	}
	
// 	var startAlong = element.attr('along') || 0;
	
// 	element.attr({along: startAlong}).animate(props, duration, easing, function() {
// 		!isElem && element.path.remove();
		
// 		callback && callback.call(element);
// 	});
// };

// SCREEN_WIDTH = 1200,
// SCREEN_HEIGHT = 1000,

// // psiTurk.showPage('stage.html');

// psiTurk.showPage('Feedback.html');
//     var R = Raphael("stim", SCREEN_WIDTH, SCREEN_HEIGHT);   //width, height of "canvas"	

//
// var receiveLikes = function(){
// 	R.clear()
// 	// //vary the number of likes people see based on condition
// 	// if(cond=="low") {
// 	// 	min=0;
//     // 	max=9;
// 	// }else if(cond=="high"){
// 	// 	min=10;
// 	// 	max=19;
// 	// }
// 	window.Numlikes=getRandomInt(1,19);
//     // window.Numlikes=getRandomInt(min,max);



// </script>

